# 🎮 玩家健康系统详细使用教程

## 📖 目录
1. [系统概述](#系统概述)
2. [快速开始](#快速开始)
3. [详细安装步骤](#详细安装步骤)
4. [UI界面设置](#ui界面设置)
5. [脚本调用方法](#脚本调用方法)
6. [测试和调试](#测试和调试)
7. [自定义配置](#自定义配置)
8. [高级功能](#高级功能)
9. [常见问题解决](#常见问题解决)
10. [完整代码示例](#完整代码示例)

---

## 📋 系统概述

这个玩家健康系统包含以下核心组件：

### 🏗️ 核心脚本
- **PlayerHealthSystem.cs** - 健康系统核心逻辑
- **HealthBarUI.cs** - UI显示和动画
- **HealthSystemExample.cs** - 使用示例和测试
- **HealthSystemSetup.cs** - 快速设置助手

### ⚡ 主要功能
- ✅ 血量管理（增加/减少/设置上限）
- ✅ 技能值管理（消耗/恢复/自动回复）
- ✅ 事件驱动UI更新
- ✅ 平滑动画效果
- ✅ 智能颜色变化
- ✅ 完整的API接口

---

## 🚀 快速开始

### 方法一：自动设置（推荐新手）

1. **添加设置脚本**
   ```
   在Unity中，将 HealthSystemSetup.cs 拖拽到场景中任意GameObject上
   ```

2. **运行游戏**
   ```
   点击Play，脚本会自动完成所有设置
   ```

### 方法二：手动设置（推荐有经验用户）

1. **添加核心系统**
   ```
   将 PlayerHealthSystem.cs 添加到您的玩家GameObject上
   ```

2. **设置UI**
   ```
   按照下面的详细步骤创建UI界面
   ```

---

## 🔧 详细安装步骤

### 步骤1：准备玩家对象

1. **确认PlayerController存在**
   ```
   检查场景中是否有PlayerController脚本的GameObject
   如果没有，请先设置好基本的玩家控制器
   ```

2. **添加健康系统**
   ```csharp
   // 在PlayerController对象上添加 PlayerHealthSystem 组件
   // 或者在代码中动态添加：
   gameObject.AddComponent<PlayerHealthSystem>();
   ```

### 步骤2：配置健康系统参数

在 **PlayerHealthSystem** 组件的Inspector面板中设置：

```
健康设置:
├── Max Health: 100          (最大血量)
├── Current Health: 100      (当前血量，运行时自动设置)

技能设置:
├── Max Skill Points: 100    (最大技能值)
├── Current Skill Points: 100 (当前技能值，运行时自动设置)

技能值恢复设置:
├── Skill Regen Rate: 5      (每秒恢复的技能值)
└── Auto Regen Skill: ✓      (是否自动恢复技能值)
```

### 步骤3：创建UI界面

#### 3.1 创建Canvas（如果没有）
```
1. 右键Hierarchy → UI → Canvas
2. 确保Canvas Scaler设置为Scale With Screen Size
```

#### 3.2 创建血量条UI结构
```
Canvas
└── HealthUI (空GameObject)
    ├── HealthBar (Slider组件)
    │   ├── Background (Image组件)
    │   ├── Fill Area (RectTransform)
    │   │   └── Fill (Image组件 - 红色)
    │   └── Background Fill (Image组件 - 半透明白色)
    ├── HealthText (TextMeshPro组件)
    ├── SkillBar (Slider组件)
    │   ├── Background (Image组件)
    │   ├── Fill Area (RectTransform)
    │   │   └── Fill (Image组件 - 蓝色)
    └── SkillText (TextMeshPro组件)
```

#### 3.3 详细UI创建步骤

**创建血量条：**
```
1. 右键HealthUI → UI → Slider
2. 重命名为"HealthBar"
3. 设置Slider属性：
   - Min Value: 0
   - Max Value: 1
   - Value: 1
4. 调整大小和位置
5. 设置Fill的颜色为红色 (#FF0000)
```

**创建技能条：**
```
1. 复制HealthBar
2. 重命名为"SkillBar"
3. 设置Fill的颜色为蓝色 (#0080FF)
4. 放置在血量条下方
```

**添加文字显示：**
```
1. 右键HealthUI → UI → Text - TextMeshPro
2. 重命名为"HealthText"
3. 设置文字内容为"100/100"
4. 调整字体大小和颜色
5. 复制一份作为"SkillText"
```

### 步骤4：连接UI组件

1. **添加HealthBarUI脚本**
   ```
   将 HealthBarUI.cs 脚本添加到 HealthUI GameObject上
   ```

2. **连接UI引用**
   在HealthBarUI组件的Inspector中：
   ```
   血量UI引用:
   ├── Health Slider: 拖拽HealthBar
   ├── Health Fill: 拖拽HealthBar的Fill
   ├── Health Text: 拖拽HealthText
   └── Health Background Fill: 拖拽Background Fill

   技能值UI引用:
   ├── Skill Slider: 拖拽SkillBar
   ├── Skill Fill: 拖拽SkillBar的Fill
   └── Skill Text: 拖拽SkillText
   ```

3. **配置UI设置**
   ```
   颜色设置:
   ├── Health Color: 红色 #FF0000
   ├── Skill Color: 蓝色 #0080FF
   ├── Low Health Color: 黄色 #FFFF00
   └── Critical Health Color: 深红色 #800000

   动画设置:
   ├── Smooth Speed: 2
   ├── Background Fade Speed: 1
   └── Smooth Transition: ✓

   阈值设置:
   ├── Low Health Threshold: 0.3 (30%)
   └── Critical Health Threshold: 0.15 (15%)
   ```

---

## 💻 脚本调用方法

### 基础调用示例

#### 造成伤害
```csharp
// 简单造成伤害
PlayerHealthSystem.instance.TakeDamage(25f);

// 获取实际造成的伤害
float actualDamage = PlayerHealthSystem.instance.TakeDamage(25f);
Debug.Log($"实际造成伤害: {actualDamage}");
```

#### 治疗血量
```csharp
// 简单治疗
PlayerHealthSystem.instance.AddHealth(30f);

// 获取实际治疗量
float actualHeal = PlayerHealthSystem.instance.AddHealth(30f);
Debug.Log($"实际治疗量: {actualHeal}");

// 治疗到满血
PlayerHealthSystem.instance.FullHeal();
```

#### 技能值管理
```csharp
// 检查技能值是否足够
if (PlayerHealthSystem.instance.HasEnoughSkillPoints(50f))
{
    // 消耗技能值
    if (PlayerHealthSystem.instance.ConsumeSkillPoints(50f))
    {
        Debug.Log("技能释放成功！");
        // 执行技能效果
    }
}

// 恢复技能值
PlayerHealthSystem.instance.AddSkillPoints(25f);

// 技能值回满
PlayerHealthSystem.instance.RestoreFullSkill();
```

### 实际游戏场景应用

#### 敌人AI攻击脚本
```csharp
public class EnemyAttack : MonoBehaviour
{
    [SerializeField] private float attackDamage = 20f;
    
    private void AttackPlayer()
    {
        // 造成伤害
        float damage = PlayerHealthSystem.instance.TakeDamage(attackDamage);
        
        // 显示伤害数字或效果
        if (damage > 0)
        {
            Debug.Log($"敌人攻击造成 {damage} 点伤害！");
            // 这里可以添加伤害特效、音效等
        }
    }
}
```

#### 物品使用脚本
```csharp
public class HealthPotion : MonoBehaviour
{
    [SerializeField] private float healAmount = 50f;
    
    public void UsePotion()
    {
        float actualHeal = PlayerHealthSystem.instance.AddHealth(healAmount);
        
        if (actualHeal > 0)
        {
            Debug.Log($"使用治疗药水，恢复 {actualHeal} 点血量");
            
            // 显示治疗效果
            if (UIManager.instance != null)
            {
                UIManager.instance.ShowNotification($"血量 +{actualHeal}", 2f);
            }
            
            // 销毁物品
            Destroy(gameObject);
        }
    }
}
```

#### 技能释放脚本
```csharp
public class PlayerSkills : MonoBehaviour
{
    [Header("技能设置")]
    [SerializeField] private float fireballCost = 30f;
    [SerializeField] private float healCost = 40f;
    [SerializeField] private float shieldCost = 50f;
    
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Q))
        {
            CastFireball();
        }
        
        if (Input.GetKeyDown(KeyCode.E))
        {
            CastHeal();
        }
        
        if (Input.GetKeyDown(KeyCode.R))
        {
            CastShield();
        }
    }
    
    private void CastFireball()
    {
        if (PlayerHealthSystem.instance.ConsumeSkillPoints(fireballCost))
        {
            Debug.Log("火球术释放！");
            // 添加火球效果
        }
        else
        {
            Debug.Log("技能值不足！");
        }
    }
    
    private void CastHeal()
    {
        if (PlayerHealthSystem.instance.ConsumeSkillPoints(healCost))
        {
            // 治疗效果
            PlayerHealthSystem.instance.AddHealth(60f);
            Debug.Log("治疗术释放！");
        }
        else
        {
            Debug.Log("技能值不足！");
        }
    }
    
    private void CastShield()
    {
        if (PlayerHealthSystem.instance.ConsumeSkillPoints(shieldCost))
        {
            Debug.Log("护盾激活！");
            // 添加护盾效果
            StartCoroutine(ShieldEffect());
        }
        else
        {
            Debug.Log("技能值不足！");
        }
    }
    
    private IEnumerator ShieldEffect()
    {
        // 5秒护盾效果
        Debug.Log("护盾生效中...");
        yield return new WaitForSeconds(5f);
        Debug.Log("护盾效果结束");
    }
}
```

### 事件订阅示例

```csharp
public class GameEventListener : MonoBehaviour
{
    private void Start()
    {
        // 订阅健康系统事件
        if (PlayerHealthSystem.instance != null)
        {
            PlayerHealthSystem.instance.OnHealthChanged += OnHealthChanged;
            PlayerHealthSystem.instance.OnSkillChanged += OnSkillChanged;
            PlayerHealthSystem.instance.OnPlayerDeath += OnPlayerDeath;
        }
    }
    
    private void OnDestroy()
    {
        // 取消订阅
        if (PlayerHealthSystem.instance != null)
        {
            PlayerHealthSystem.instance.OnHealthChanged -= OnHealthChanged;
            PlayerHealthSystem.instance.OnSkillChanged -= OnSkillChanged;
            PlayerHealthSystem.instance.OnPlayerDeath -= OnPlayerDeath;
        }
    }
    
    private void OnHealthChanged(float current, float max)
    {
        float percentage = current / max;
        
        if (percentage <= 0.2f)
        {
            // 血量危险，播放心跳音效
            PlayHeartbeatSound();
        }
    }
    
    private void OnSkillChanged(float current, float max)
    {
        float percentage = current / max;
        
        if (percentage >= 1f)
        {
            // 技能值满了，播放充能完成音效
            PlayManaFullSound();
        }
    }
    
    private void OnPlayerDeath()
    {
        Debug.Log("玩家死亡！");
        
        // 停止游戏或显示死亡界面
        Time.timeScale = 0f;
        
        // 显示重生界面
        // ShowRespawnUI();
    }
    
    private void PlayHeartbeatSound()
    {
        // 播放心跳音效
    }
    
    private void PlayManaFullSound()
    {
        // 播放技能值满的音效
    }
}
```

---

## 🧪 测试和调试

### 使用测试脚本

1. **添加测试组件**
   ```
   将 HealthSystemExample.cs 添加到玩家对象上
   ```

2. **测试按键**
   ```
   H - 造成伤害 (10点)
   J - 治疗 (15点)
   K - 消耗技能值 (20点)
   L - 恢复技能值 (25点)
   R - 重置到满值
   
   1 - 火球术 (消耗30点技能值)
   2 - 治疗术 (消耗40点技能值，恢复50点血量)
   3 - 护盾 (消耗50点技能值)
   ```

3. **查看调试信息**
   ```csharp
   // 在任何地方调用，获取当前状态
   Debug.Log(PlayerHealthSystem.instance.GetStatusInfo());
   
   // 输出示例：
   // 血量: 75.0/100.0 (75%)
   // 技能: 60.0/100.0 (60%)
   // 状态: 存活
   ```

### Inspector调试

在游戏运行时，您可以在Inspector中实时看到：
- 当前血量和最大血量
- 当前技能值和最大技能值
- 技能恢复速度
- 是否自动恢复技能值

### 常用调试代码

```csharp
// 检查系统是否正常工作
if (PlayerHealthSystem.instance == null)
{
    Debug.LogError("PlayerHealthSystem未找到！");
}

// 检查当前状态
var health = PlayerHealthSystem.instance;
Debug.Log($"血量百分比: {health.HealthPercentage:P}");
Debug.Log($"技能百分比: {health.SkillPercentage:P}");
Debug.Log($"是否死亡: {health.IsDead}");

// 强制触发事件测试
health.OnHealthChanged?.Invoke(health.CurrentHealth, health.MaxHealth);
```

---

## ⚙️ 自定义配置

### 修改默认数值

在 **PlayerHealthSystem** 脚本中：
```csharp
[Header("健康设置")]
[SerializeField] private float maxHealth = 150f;        // 改为150血量
[SerializeField] private float currentHealth;

[Header("技能设置")]
[SerializeField] private float maxSkillPoints = 200f;   // 改为200技能值
[SerializeField] private float currentSkillPoints;

[Header("技能值恢复设置")]
[SerializeField] private float skillRegenRate = 10f;    // 改为每秒恢复10点
```

### 自定义UI颜色和效果

在 **HealthBarUI** 脚本中：
```csharp
[Header("颜色设置")]
[SerializeField] private Color healthColor = Color.green;     // 改为绿色血量条
[SerializeField] private Color skillColor = Color.yellow;     // 改为黄色技能条
[SerializeField] private Color lowHealthColor = Color.orange; // 改为橙色低血量
[SerializeField] private Color criticalHealthColor = Color.red;

[Header("动画设置")]
[SerializeField] private float smoothSpeed = 5f;             // 更快的动画
[SerializeField] private float backgroundFadeSpeed = 2f;     // 更快的背景消失

[Header("阈值设置")]
[SerializeField] private float lowHealthThreshold = 0.5f;    // 50%以下显示低血量颜色
[SerializeField] private float criticalHealthThreshold = 0.2f; // 20%以下显示危险颜色
```

### 添加自定义功能

#### 护甲系统
```csharp
public class ArmorSystem : MonoBehaviour
{
    [SerializeField] private float armorValue = 10f;
    
    private void Start()
    {
        // 订阅伤害事件，在伤害应用前进行护甲计算
        PlayerHealthSystem.instance.OnHealthChanged += OnDamageTaken;
    }
    
    private void OnDamageTaken(float current, float max)
    {
        // 护甲减伤逻辑
    }
    
    // 修改PlayerHealthSystem的TakeDamage方法以支持护甲
    public float CalculateArmorDamage(float damage)
    {
        return Mathf.Max(1f, damage - armorValue); // 最少造成1点伤害
    }
}
```

#### 经验和升级系统
```csharp
public class LevelSystem : MonoBehaviour
{
    [SerializeField] private int currentLevel = 1;
    [SerializeField] private float currentExp = 0f;
    [SerializeField] private float expToNextLevel = 100f;
    
    public void AddExperience(float exp)
    {
        currentExp += exp;
        
        if (currentExp >= expToNextLevel)
        {
            LevelUp();
        }
    }
    
    private void LevelUp()
    {
        currentLevel++;
        currentExp -= expToNextLevel;
        expToNextLevel *= 1.2f; // 每级需要的经验增加20%
        
        // 升级时增加血量和技能值上限
        float healthIncrease = 20f;
        float skillIncrease = 15f;
        
        var health = PlayerHealthSystem.instance;
        health.SetMaxHealth(health.MaxHealth + healthIncrease, true);
        health.SetMaxSkillPoints(health.MaxSkillPoints + skillIncrease, true);
        
        Debug.Log($"升级到 {currentLevel} 级！血量上限 +{healthIncrease}，技能值上限 +{skillIncrease}");
    }
}
```

---

## 🔮 高级功能

### 状态效果系统

```csharp
public class StatusEffectSystem : MonoBehaviour
{
    [System.Serializable]
    public class StatusEffect
    {
        public string name;
        public float duration;
        public float healthPerSecond;  // 每秒血量变化（正数回血，负数掉血）
        public float skillPerSecond;   // 每秒技能值变化
    }
    
    private List<StatusEffect> activeEffects = new List<StatusEffect>();
    
    public void ApplyStatusEffect(StatusEffect effect)
    {
        activeEffects.Add(effect);
        StartCoroutine(ProcessStatusEffect(effect));
    }
    
    private IEnumerator ProcessStatusEffect(StatusEffect effect)
    {
        float timer = 0f;
        
        while (timer < effect.duration)
        {
            // 应用每秒效果
            if (effect.healthPerSecond != 0)
            {
                if (effect.healthPerSecond > 0)
                {
                    PlayerHealthSystem.instance.AddHealth(effect.healthPerSecond * Time.deltaTime);
                }
                else
                {
                    PlayerHealthSystem.instance.TakeDamage(-effect.healthPerSecond * Time.deltaTime);
                }
            }
            
            if (effect.skillPerSecond != 0)
            {
                PlayerHealthSystem.instance.AddSkillPoints(effect.skillPerSecond * Time.deltaTime);
            }
            
            timer += Time.deltaTime;
            yield return null;
        }
        
        activeEffects.Remove(effect);
        Debug.Log($"状态效果 {effect.name} 结束");
    }
    
    // 使用示例
    public void ApplyPoisonEffect()
    {
        StatusEffect poison = new StatusEffect
        {
            name = "中毒",
            duration = 10f,
            healthPerSecond = -5f,  // 每秒掉5血
            skillPerSecond = 0f
        };
        ApplyStatusEffect(poison);
    }
    
    public void ApplyRegenerationEffect()
    {
        StatusEffect regen = new StatusEffect
        {
            name = "恢复",
            duration = 15f,
            healthPerSecond = 3f,   // 每秒回3血
            skillPerSecond = 2f     // 每秒回2技能值
        };
        ApplyStatusEffect(regen);
    }
}
```

### 保存和读取系统

```csharp
[System.Serializable]
public class HealthSystemSaveData
{
    public float currentHealth;
    public float maxHealth;
    public float currentSkillPoints;
    public float maxSkillPoints;
    public float skillRegenRate;
    public bool autoRegenSkill;
}

public static class HealthSystemSaveManager
{
    private const string SAVE_KEY = "HealthSystemData";
    
    public static void SaveHealthSystem()
    {
        var health = PlayerHealthSystem.instance;
        if (health == null) return;
        
        HealthSystemSaveData data = new HealthSystemSaveData
        {
            currentHealth = health.CurrentHealth,
            maxHealth = health.MaxHealth,
            currentSkillPoints = health.CurrentSkillPoints,
            maxSkillPoints = health.MaxSkillPoints,
            // 保存其他需要的数据
        };
        
        string json = JsonUtility.ToJson(data);
        PlayerPrefs.SetString(SAVE_KEY, json);
        PlayerPrefs.Save();
        
        Debug.Log("健康系统数据已保存");
    }
    
    public static void LoadHealthSystem()
    {
        if (!PlayerPrefs.HasKey(SAVE_KEY)) return;
        
        string json = PlayerPrefs.GetString(SAVE_KEY);
        HealthSystemSaveData data = JsonUtility.FromJson<HealthSystemSaveData>(json);
        
        var health = PlayerHealthSystem.instance;
        if (health == null) return;
        
        // 恢复数据
        health.SetMaxHealth(data.maxHealth, false);
        health.SetMaxSkillPoints(data.maxSkillPoints, false);
        // 设置当前值需要通过反射或添加新的方法
        
        Debug.Log("健康系统数据已加载");
    }
}

// 在适当的地方调用
public class GameManager : MonoBehaviour
{
    private void Start()
    {
        HealthSystemSaveManager.LoadHealthSystem();
    }
    
    private void OnApplicationPause(bool pauseStatus)
    {
        if (pauseStatus)
        {
            HealthSystemSaveManager.SaveHealthSystem();
        }
    }
    
    private void OnApplicationFocus(bool hasFocus)
    {
        if (!hasFocus)
        {
            HealthSystemSaveManager.SaveHealthSystem();
        }
    }
}
```

---

## ❗ 常见问题解决

### Q1: UI不显示或不更新
**原因：** UI组件连接不正确或PlayerHealthSystem不存在

**解决方案：**
```csharp
// 检查PlayerHealthSystem是否存在
if (PlayerHealthSystem.instance == null)
{
    Debug.LogError("PlayerHealthSystem实例未找到！请确保脚本已添加到场景中。");
}

// 检查UI组件是否连接
if (healthSlider == null)
{
    Debug.LogError("血量滑动条未连接！请在Inspector中设置Health Slider字段。");
}
```

### Q2: 事件不触发
**原因：** 事件订阅时机不对或对象已销毁

**解决方案：**
```csharp
private void Start()
{
    // 延迟一帧确保PlayerHealthSystem已初始化
    StartCoroutine(SubscribeToHealthEvents());
}

private IEnumerator SubscribeToHealthEvents()
{
    yield return null; // 等待一帧
    
    if (PlayerHealthSystem.instance != null)
    {
        PlayerHealthSystem.instance.OnHealthChanged += UpdateHealthDisplay;
    }
    else
    {
        Debug.LogWarning("PlayerHealthSystem仍未找到，稍后重试...");
        yield return new WaitForSeconds(0.1f);
        StartCoroutine(SubscribeToHealthEvents());
    }
}
```

### Q3: 技能值不自动恢复
**原因：** autoRegenSkill设置为false或skillRegenRate为0

**解决方案：**
```csharp
// 在Inspector中检查设置
// 或在代码中强制设置
private void Start()
{
    var health = PlayerHealthSystem.instance;
    if (health != null)
    {
        // 通过反射设置私有字段，或添加公共设置方法
        Debug.Log("请在Inspector中确保Auto Regen Skill已勾选，Skill Regen Rate大于0");
    }
}
```

### Q4: 血量条动画不流畅
**原因：** smoothSpeed设置过低或帧率问题

**解决方案：**
```csharp
// 在HealthBarUI脚本中调整动画速度
[SerializeField] private float smoothSpeed = 5f; // 增加数值使动画更快

// 或者关闭平滑动画
[SerializeField] private bool smoothTransition = false;
```

### Q5: 单例模式冲突
**原因：** 场景中有多个PlayerHealthSystem实例

**解决方案：**
```csharp
// 在PlayerHealthSystem的Awake方法中添加更详细的检查
private void Awake()
{
    if (instance == null)
    {
        instance = this;
        DontDestroyOnLoad(gameObject); // 可选：跨场景保持
    }
    else if (instance != this)
    {
        Debug.LogWarning($"检测到重复的PlayerHealthSystem实例！销毁 {gameObject.name}");
        Destroy(gameObject);
        return;
    }
}
```

### Q6: TextMeshPro相关错误
**原因：** 项目中未导入TextMeshPro包

**解决方案：**
```
1. 在Unity中打开 Window → TextMeshPro → Import TMP Essential Resources
2. 或者将HealthBarUI脚本中的TextMeshProUGUI改为Text组件
```

---

## 📝 完整代码示例

### 简单的敌人AI示例
```csharp
using UnityEngine;

public class SimpleEnemy : MonoBehaviour
{
    [Header("攻击设置")]
    [SerializeField] private float attackDamage = 15f;
    [SerializeField] private float attackRange = 2f;
    [SerializeField] private float attackCooldown = 2f;
    
    private float lastAttackTime;
    private Transform player;
    
    private void Start()
    {
        player = PlayerController.instance.transform;
    }
    
    private void Update()
    {
        // 检查玩家距离
        float distanceToPlayer = Vector3.Distance(transform.position, player.position);
        
        if (distanceToPlayer <= attackRange && Time.time >= lastAttackTime + attackCooldown)
        {
            AttackPlayer();
            lastAttackTime = Time.time;
        }
    }
    
    private void AttackPlayer()
    {
        if (PlayerHealthSystem.instance != null)
        {
            float actualDamage = PlayerHealthSystem.instance.TakeDamage(attackDamage);
            Debug.Log($"敌人攻击造成 {actualDamage} 点伤害！");
            
            // 显示伤害效果
            if (UIManager.instance != null)
            {
                UIManager.instance.ShowNotification($"-{actualDamage:F0}", 1.5f);
            }
        }
    }
    
    private void OnDrawGizmosSelected()
    {
        // 在Scene视图中显示攻击范围
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRange);
    }
}
```

### 物品拾取系统示例
```csharp
using UnityEngine;

public class PickupItem : MonoBehaviour
{
    [Header("物品设置")]
    [SerializeField] private ItemType itemType;
    [SerializeField] private float value = 25f;
    [SerializeField] private string itemName = "治疗药水";
    
    public enum ItemType
    {
        HealthPotion,
        ManaPotion,
        HealthUpgrade,
        ManaUpgrade
    }
    
    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            UseItem();
        }
    }
    
    private void UseItem()
    {
        var health = PlayerHealthSystem.instance;
        if (health == null) return;
        
        switch (itemType)
        {
            case ItemType.HealthPotion:
                float healAmount = health.AddHealth(value);
                ShowPickupMessage($"{itemName} +{healAmount:F0} 血量");
                break;
                
            case ItemType.ManaPotion:
                float manaAmount = health.AddSkillPoints(value);
                ShowPickupMessage($"{itemName} +{manaAmount:F0} 技能值");
                break;
                
            case ItemType.HealthUpgrade:
                health.SetMaxHealth(health.MaxHealth + value, true);
                ShowPickupMessage($"{itemName} 最大血量 +{value:F0}");
                break;
                
            case ItemType.ManaUpgrade:
                health.SetMaxSkillPoints(health.MaxSkillPoints + value, true);
                ShowPickupMessage($"{itemName} 最大技能值 +{value:F0}");
                break;
        }
        
        // 播放拾取音效
        // AudioSource.PlayClipAtPoint(pickupSound, transform.position);
        
        // 播放拾取特效
        // Instantiate(pickupEffect, transform.position, Quaternion.identity);
        
        // 销毁物品
        Destroy(gameObject);
    }
    
    private void ShowPickupMessage(string message)
    {
        Debug.Log(message);
        
        if (UIManager.instance != null)
        {
            UIManager.instance.ShowNotification(message, 2f);
        }
    }
}
```

---

## 🎯 总结

这个玩家健康系统提供了：

1. **完整的血量和技能值管理**
2. **事件驱动的UI更新系统**
3. **平滑的动画效果**
4. **智能的颜色变化提示**
5. **丰富的API接口**
6. **详细的使用示例**
7. **扩展性强的架构**

您可以根据游戏需求进行各种自定义，系统已经为常见的游戏功能做好了准备。

如果您有任何问题或需要进一步的自定义功能，请随时询问！

---

## 📞 技术支持

如需帮助，请检查以下内容：
1. 确保所有脚本都正确添加到相应的GameObject上
2. 检查UI组件是否正确连接
3. 查看Console是否有错误信息
4. 使用测试脚本验证功能是否正常

**常用调试命令：**
```csharp
// 在Console中查看当前状态
Debug.Log(PlayerHealthSystem.instance.GetStatusInfo());

// 测试基本功能
PlayerHealthSystem.instance.TakeDamage(10f);
PlayerHealthSystem.instance.AddHealth(10f);
PlayerHealthSystem.instance.ConsumeSkillPoints(10f);
PlayerHealthSystem.instance.AddSkillPoints(10f);
```